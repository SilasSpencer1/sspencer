<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Marble Solitaire - Silas Spencer</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Bootstrap Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;500;600;700&family=Raleway:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inconsolata', monospace;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .glass-board {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 25px 45px rgba(0, 0, 0, 0.1);
            padding: 32px;
            margin: 0 auto;
            max-width: fit-content;
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(7, 1fr);
            gap: 8px;
            width: 400px;
            height: 400px;
            margin: 0 auto;
        }
        .hole {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            position: relative;
            transition: all 0.3s ease;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .hole.valid-drop {
            background: rgba(34, 197, 94, 0.3);
            border-color: rgba(34, 197, 94, 0.5);
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.4), inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .hole.invalid {
            background: rgba(239, 68, 68, 0.3);
            border-color: rgba(239, 68, 68, 0.5);
        }
        .marble {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.9), rgba(168, 85, 247, 0.9));
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            cursor: grab;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
            box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }
        .marble:hover {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 12px 40px rgba(139, 92, 246, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }
        .marble.dragging {
            cursor: grabbing;
            z-index: 1000;
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 16px 48px rgba(139, 92, 246, 0.5), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }
        .marble.selected {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.9), rgba(217, 119, 6, 0.9));
            box-shadow: 0 8px 32px rgba(245, 158, 11, 0.4), 
                        inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }
        .invalid-board-cell {
            background: transparent;
            border: none;
        }
        .fade-in-element {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s ease-out, transform 0.6s ease-out;
        }
        .fade-in-element.is-visible {
            opacity: 1;
            transform: translateY(0);
        }
        @keyframes celebration {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .celebrate {
            animation: celebration 0.5s ease-in-out 3;
        }
        .shape-btn {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.875rem;
            font-weight: 500;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        .shape-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        .shape-btn.active {
            background: rgba(139, 92, 246, 0.4);
            border-color: rgba(139, 92, 246, 0.5);
            color: white;
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.3);
        }
        .game-board.triangle {
            width: 350px;
            height: 350px;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
        }
        .game-board.diamond {
            width: 350px;
            height: 350px;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
        }
        .game-board.plus {
            width: 300px;
            height: 300px;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
        }
        .game-board.custom {
            width: 400px;
            height: 400px;
        }
        .board-designer {
            width: 320px;
            height: 320px;
            margin: 0 auto;
            padding: 15px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }
        .designer-cell {
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            box-sizing: border-box;
            position: absolute;
            backdrop-filter: blur(5px);
        }
        .designer-cell.marble {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.8), rgba(168, 85, 247, 0.8));
            border-color: rgba(139, 92, 246, 0.5);
            color: white;
            opacity: 1;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
        }
        .designer-cell.marble i {
            position: static;
            transform: none !important;
        }
        .designer-cell.empty {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.8);
            opacity: 1;
        }
        .designer-cell.invalid {
            background: rgba(255, 255, 255, 0.1);
            border: 1px dashed rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.4);
            opacity: 0.7;
        }
        .designer-cell:hover:not(.invalid) {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        .designer-mode-btn.active {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        .glass-panel {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(15px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }
        .glass-panel h3 {
            color: rgba(255, 255, 255, 0.95);
        }
        .glass-panel h4 {
            color: rgba(255, 255, 255, 0.9);
        }
        .glass-panel p {
            color: rgba(255, 255, 255, 0.8);
        }
        .glass-panel input {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            color: rgba(255, 255, 255, 0.9);
            padding: 12px 16px;
        }
        .glass-panel input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        .glass-panel input:focus {
            outline: none;
            border-color: rgba(139, 92, 246, 0.5);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
        }
        .glass-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 16px;
            color: rgba(255, 255, 255, 0.95);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        .glass-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
    </style>
</head>
<body class="antialiased">

<div class="container mx-auto max-w-6xl px-4 sm:px-6 lg:px-8 py-8 md:py-16">
    
    <!-- Back to Projects -->
    <div class="mb-8">
        <a href="projects.html" class="inline-flex items-center text-purple-600 hover:text-purple-800 transition-colors">
            <i class="bi bi-arrow-left mr-2"></i> Back to Projects
        </a>
    </div>

    <!-- Game Header -->
    <div class="text-center mb-8 fade-in-element glass-panel p-6">
        <h1 class="text-4xl font-bold text-white mb-4">Marble Solitaire</h1>
        <p class="text-lg text-white text-opacity-80 mb-6">Jump marbles over each other to remove them. Goal: Leave only one marble in the center!</p>
        
        <!-- Game Stats -->
        <div class="flex justify-center space-x-8 mb-6">
            <div class="text-center">
                <div class="text-2xl font-bold text-white" id="marbles-count">32</div>
                <div class="text-sm text-white text-opacity-70">Marbles Left</div>
            </div>
            <div class="text-center">
                <div class="text-2xl font-bold text-white" id="moves-count">0</div>
                <div class="text-sm text-white text-opacity-70">Moves Made</div>
            </div>
        </div>
        
        <!-- Shape Selector -->
        <div class="mb-6">
            <h3 class="text-lg font-semibold text-white mb-3">Choose Board Shape:</h3>
            <div class="flex justify-center space-x-4 flex-wrap gap-2">
                <button class="shape-btn active" data-shape="cross">
                    <i class="bi bi-plus-lg mr-2"></i>Cross (Classic)
                </button>
                <button class="shape-btn" data-shape="triangle">
                    <i class="bi bi-triangle mr-2"></i>Triangle
                </button>
                <button class="shape-btn" data-shape="diamond">
                    <i class="bi bi-diamond mr-2"></i>Diamond
                </button>
                <button class="shape-btn" data-shape="plus">
                    <i class="bi bi-plus-circle mr-2"></i>Plus
                </button>
                <button class="shape-btn" data-shape="custom">
                    <i class="bi bi-pencil-square mr-2"></i>Custom Design
                    <span class="text-xs bg-orange-100 text-orange-800 px-1 py-0.5 rounded ml-1">BETA</span>
                </button>
            </div>
        </div>

        <!-- Custom Board Designer (hidden by default) -->
        <div id="custom-designer" class="mb-6 glass-panel p-6 hidden">
            <h3 class="text-lg font-semibold text-purple-900 mb-4">
                Design Your Custom Board 
                <span class="text-xs bg-orange-100 text-orange-800 px-2 py-1 rounded-full ml-2">BETA</span>
            </h3>
            
            <!-- Description Input Method -->
            <div class="mb-6">
                <h4 class="text-md font-medium text-purple-800 mb-2">Method 1: Describe Your Shape</h4>
                <div class="flex gap-3 mb-2">
                    <input type="text" id="shape-description" placeholder="Describe your shape (e.g., 'letter L', 'heart shape', 'arrow pointing up')" 
                           class="flex-1 px-3 py-2 border border-purple-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500">
                    <button id="generate-from-description" class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors">
                        <i class="bi bi-magic mr-2"></i>Generate
                    </button>
                </div>
                <p class="text-sm text-purple-600">Try: "star", "heart", "letter T", "arrow", "hourglass", "butterfly", "diamond", "tree", etc.</p>
            </div>

            <!-- Visual Designer Method -->
            <div class="mb-6">
                <h4 class="text-md font-medium text-purple-800 mb-2">Method 2: Visual Designer</h4>
                <div class="flex gap-4 mb-3">
                    <button id="designer-marble" class="designer-mode-btn px-3 py-1 bg-purple-600 text-white rounded text-sm active">
                        <i class="bi bi-circle-fill mr-1"></i>Place Marble
                    </button>
                    <button id="designer-empty" class="designer-mode-btn px-3 py-1 bg-gray-100 text-gray-600 rounded text-sm">
                        <i class="bi bi-circle mr-1"></i>Empty Hole
                    </button>
                    <button id="designer-invalid" class="designer-mode-btn px-3 py-1 bg-gray-100 text-gray-600 rounded text-sm">
                        <i class="bi bi-x-circle mr-1"></i>No Hole
                    </button>
                    <button id="clear-designer" class="px-3 py-1 bg-gray-500 text-white rounded text-sm">
                        <i class="bi bi-arrow-clockwise mr-1"></i>Clear
                    </button>
                </div>
                <div id="board-designer" class="inline-block border-2 border-purple-300 rounded-lg p-2 bg-white"></div>
                <p class="text-sm text-purple-600 mt-2">Click grid cells to design your board. Ensure you have exactly one empty starting hole!</p>
            </div>

            <!-- Actions -->
            <div class="flex gap-3">
                <button id="test-custom-board" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors">
                    <i class="bi bi-play-circle mr-2"></i>Test Board
                </button>
                <button id="save-custom-board" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                    <i class="bi bi-save mr-2"></i>Save Design
                </button>
                <button id="cancel-custom" class="px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                    <i class="bi bi-x-lg mr-2"></i>Cancel
                </button>
            </div>
        </div>

        <!-- Control Buttons -->
        <div class="flex justify-center space-x-4">
            <button id="reset-btn" class="glass-btn">
                <i class="bi bi-arrow-clockwise mr-2"></i>New Game
            </button>
            <button id="hint-btn" class="glass-btn">
                <i class="bi bi-lightbulb mr-2"></i>Show Hint
            </button>
        </div>
    </div>

    <!-- Game Board -->
    <div class="fade-in-element">
        <div class="glass-board">
            <div id="game-board" class="game-board"></div>
        </div>
    </div>

    <!-- Instructions -->
    <div class="mt-8 glass-panel p-6 fade-in-element">
        <h3 class="text-lg font-bold text-white mb-3">How to Play:</h3>
        <ul class="text-white text-opacity-80 space-y-2">
            <li><i class="bi bi-1-circle-fill mr-2"></i>Click and drag a marble to jump over an adjacent marble</li>
            <li><i class="bi bi-2-circle-fill mr-2"></i>The jumped marble will be removed from the board</li>
            <li><i class="bi bi-3-circle-fill mr-2"></i>You can only jump horizontally or vertically, not diagonally</li>
            <li><i class="bi bi-4-circle-fill mr-2"></i>The goal is to end with only one marble remaining in the center</li>
        </ul>
    </div>

    <!-- Win Modal -->
    <div id="win-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg p-8 max-w-md mx-4 text-center">
            <div class="text-6xl mb-4">🎉</div>
            <h2 class="text-2xl font-bold text-gray-900 mb-2">Congratulations!</h2>
            <p class="text-gray-600 mb-4">You completed the puzzle in <span id="final-moves"></span> moves!</p>
            <button id="play-again-btn" class="px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors">
                Play Again
            </button>
        </div>
    </div>

</div>

<script>
class MarbleSolitaire {
    constructor() {
        this.currentShape = 'cross';
        this.customBoard = null;
        this.designerMode = 'marble'; // marble, empty, invalid
        this.board = this.initializeBoard();
        this.selectedMarble = null;
        this.moves = 0;
        this.gameBoard = document.getElementById('game-board');
        this.marblesCount = document.getElementById('marbles-count');
        this.movesCount = document.getElementById('moves-count');
        this.winModal = document.getElementById('win-modal');
        this.customDesigner = document.getElementById('custom-designer');
        
        this.setupEventListeners();
        this.initializeBoardDesigner();
        this.renderBoard();
        this.updateStats();
    }

    initializeBoard() {
        switch (this.currentShape) {
            case 'cross':
                return this.createCrossBoard();
            case 'triangle':
                return this.createTriangleBoard();
            case 'diamond':
                return this.createDiamondBoard();
            case 'plus':
                return this.createPlusBoard();
            case 'custom':
                return this.createCustomBoard();
            default:
                return this.createCrossBoard();
        }
    }

    createCrossBoard() {
        // 7x7 board with cross pattern
        return [
            [null, null, 1, 1, 1, null, null],
            [null, null, 1, 1, 1, null, null],
            [1, 1, 1, 1, 1, 1, 1],
            [1, 1, 1, 0, 1, 1, 1], // Center is empty
            [1, 1, 1, 1, 1, 1, 1],
            [null, null, 1, 1, 1, null, null],
            [null, null, 1, 1, 1, null, null]
        ];
    }

    createTriangleBoard() {
        // 5x5 board with triangle pattern
        return [
            [null, null, 0, null, null], // Top is empty
            [null, 1, 1, 1, null],
            [1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1],
            [1, 1, 1, 1, 1]
        ];
    }

    createDiamondBoard() {
        // 5x5 board with diamond pattern
        return [
            [null, null, 1, null, null],
            [null, 1, 1, 1, null],
            [1, 1, 0, 1, 1], // Center is empty
            [null, 1, 1, 1, null],
            [null, null, 1, null, null]
        ];
    }

    createPlusBoard() {
        // 5x5 board with plus pattern
        return [
            [null, null, 1, null, null],
            [null, null, 1, null, null],
            [1, 1, 0, 1, 1], // Center is empty
            [null, null, 1, null, null],
            [null, null, 1, null, null]
        ];
    }

    createCustomBoard() {
        if (this.customBoard) {
            return JSON.parse(JSON.stringify(this.customBoard)); // Deep clone
        }
        // Default to cross if no custom board set
        return this.createCrossBoard();
    }

    initializeBoardDesigner() {
        const designer = document.getElementById('board-designer');
        if (!designer) {
            console.error('Board designer element not found');
            return;
        }
        
        designer.className = 'board-designer';
        designer.innerHTML = '';
        
        // Create 7x7 grid for designer using absolute positioning
        const cellSize = 35;
        const cellGap = 3;
        const totalGridSize = 7 * cellSize + 6 * cellGap; // Should be 269px
        const containerContentSize = 320 - 30; // 290px (width - padding)
        
        console.log(`Grid will be ${totalGridSize}px, container content is ${containerContentSize}px`);
        
        let cellCount = 0;
        
        for (let row = 0; row < 7; row++) {
            for (let col = 0; col < 7; col++) {
                const cell = document.createElement('div');
                cell.className = 'designer-cell invalid';
                cell.dataset.row = row;
                cell.dataset.col = col;
                cell.title = `Row ${row}, Col ${col}`;
                cell.innerHTML = `<small style="font-size: 7px; color: #999;">${row},${col}</small>`;
                cell.addEventListener('click', () => this.handleDesignerClick(row, col));
                
                // Calculate position - centered in container
                const x = col * (cellSize + cellGap);
                const y = row * (cellSize + cellGap);
                cell.style.left = `${x}px`;
                cell.style.top = `${y}px`;
                cell.style.width = `${cellSize}px`;
                cell.style.height = `${cellSize}px`;
                
                designer.appendChild(cell);
                cellCount++;
            }
        }
        
        console.log(`Created ${cellCount} designer cells at absolute positions`);
    }

    handleDesignerClick(row, col) {
        const cell = document.querySelector(`#board-designer [data-row="${row}"][data-col="${col}"]`);
        
        if (!cell) {
            console.error(`Cell not found at row ${row}, col ${col}`);
            return;
        }
        
        console.log(`Clicked cell at row ${row}, col ${col}`);
        
        switch (this.designerMode) {
            case 'marble':
                cell.className = 'designer-cell marble';
                cell.innerHTML = '<i class="bi bi-circle-fill"></i>';
                break;
            case 'empty':
                cell.className = 'designer-cell empty';
                cell.innerHTML = '<i class="bi bi-circle"></i>';
                break;
            case 'invalid':
                cell.className = 'designer-cell invalid';
                cell.innerHTML = `<small style="font-size: 7px; color: #999;">${row},${col}</small>`;
                break;
        }
    }

    setDesignerMode(mode) {
        this.designerMode = mode;
        
        // Update button states
        document.querySelectorAll('.designer-mode-btn').forEach(btn => {
            btn.classList.remove('active', 'bg-purple-600', 'text-white', 'bg-gray-300', 'text-gray-700', 'bg-red-200', 'text-red-700', 'bg-gray-100', 'text-gray-600');
            
            if (btn.id.includes(mode)) {
                btn.classList.add('active');
                if (mode === 'marble') {
                    btn.classList.add('bg-purple-600', 'text-white');
                } else if (mode === 'empty') {
                    btn.classList.add('bg-gray-300', 'text-gray-700');
                } else if (mode === 'invalid') {
                    btn.classList.add('bg-red-200', 'text-red-700');
                }
            } else {
                btn.classList.add('bg-gray-100', 'text-gray-600');
            }
        });
    }

    clearDesigner() {
        document.querySelectorAll('#board-designer .designer-cell').forEach(cell => {
            cell.className = 'designer-cell invalid';
            const row = cell.dataset.row;
            const col = cell.dataset.col;
            cell.innerHTML = `<small style="font-size: 7px; color: #999;">${row},${col}</small>`;
            // Ensure no inline styles are affecting position
            cell.style.transform = '';
        });
        console.log('Designer cleared');
    }

    boardFromDesigner() {
        const board = Array(7).fill().map(() => Array(7).fill(null));
        
        document.querySelectorAll('.designer-cell').forEach(cell => {
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            if (cell.classList.contains('marble')) {
                board[row][col] = 1;
            } else if (cell.classList.contains('empty')) {
                board[row][col] = 0;
            }
            // invalid cells remain null
        });
        
        return board;
    }

    validateCustomBoard(board) {
        const flatBoard = board.flat();
        const marbleCount = flatBoard.filter(cell => cell === 1).length;
        const emptyCount = flatBoard.filter(cell => cell === 0).length;
        
        if (marbleCount < 2) {
            return { valid: false, message: "Need at least 2 marbles to play!" };
        }
        
        if (emptyCount !== 1) {
            return { valid: false, message: "Must have exactly 1 empty starting hole!" };
        }
        
        return { valid: true, message: "Board looks good!" };
    }

    generateFromDescription(description) {
        const cleanDescription = description.toLowerCase().trim();
        console.log('Trying to generate shape for:', cleanDescription);
        
        const shapes = this.parseShapeDescription(cleanDescription);
        console.log('Generated shape pattern:', shapes ? 'SUCCESS' : 'FAILED');
        
        if (shapes) {
            console.log('Shape pattern preview:', shapes.map(row => row.map(cell => cell === 1 ? 'M' : cell === 0 ? 'E' : ' ').join('')));
            this.displayShapeOnDesigner(shapes);
            return true;
        }
        return false;
    }

    parseShapeDescription(description) {
        // Enhanced pattern matching for common shapes
        const patterns = {
            'star': [
                [null, null, null, 0, null, null, null],
                [null, null, 1, 1, 1, null, null],
                [null, 1, 1, 1, 1, 1, null],
                [1, 1, 1, 1, 1, 1, 1],
                [null, 1, 1, 1, 1, 1, null],
                [null, 1, null, 1, null, 1, null],
                [1, null, null, null, null, null, 1]
            ],
            'heart': [
                [null, 1, 1, null, 1, 1, null],
                [1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 0, 1, 1, 1],
                [null, 1, 1, 1, 1, 1, null],
                [null, null, 1, 1, 1, null, null],
                [null, null, null, 1, null, null, null],
                [null, null, null, null, null, null, null]
            ],
            'letter t': [
                [1, 1, 1, 1, 1, null, null],
                [null, null, 0, null, null, null, null],
                [null, null, 1, null, null, null, null],
                [null, null, 1, null, null, null, null],
                [null, null, 1, null, null, null, null],
                [null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null]
            ],
            'arrow': [
                [null, null, null, 0, null, null, null],
                [null, null, 1, 1, 1, null, null],
                [null, 1, 1, 1, 1, 1, null],
                [1, 1, 1, 1, 1, 1, 1],
                [null, null, null, 1, null, null, null],
                [null, null, null, 1, null, null, null],
                [null, null, null, 1, null, null, null]
            ],
            'letter l': [
                [1, null, null, null, null, null, null],
                [1, null, null, null, null, null, null],
                [1, null, null, null, null, null, null],
                [0, null, null, null, null, null, null],
                [1, 1, 1, 1, 1, null, null],
                [null, null, null, null, null, null, null],
                [null, null, null, null, null, null, null]
            ],
            'hourglass': [
                [1, 1, 1, 1, 1, 1, 1],
                [null, 1, 1, 1, 1, 1, null],
                [null, null, 1, 1, 1, null, null],
                [null, null, null, 0, null, null, null],
                [null, null, 1, 1, 1, null, null],
                [null, 1, 1, 1, 1, 1, null],
                [1, 1, 1, 1, 1, 1, 1]
            ],
            'butterfly': [
                [1, 1, null, null, null, 1, 1],
                [1, 1, 1, null, 1, 1, 1],
                [1, 1, 1, null, 1, 1, 1],
                [null, 1, 1, 0, 1, 1, null],
                [1, 1, 1, null, 1, 1, 1],
                [1, 1, 1, null, 1, 1, 1],
                [1, 1, null, null, null, 1, 1]
            ],
            'diamond': [
                [null, null, null, 1, null, null, null],
                [null, null, 1, 1, 1, null, null],
                [null, 1, 1, 1, 1, 1, null],
                [1, 1, 1, 0, 1, 1, 1],
                [null, 1, 1, 1, 1, 1, null],
                [null, null, 1, 1, 1, null, null],
                [null, null, null, 1, null, null, null]
            ],
            'smiley': [
                [null, 1, 1, 1, 1, 1, null],
                [1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 0, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1],
                [null, 1, 1, 1, 1, 1, null]
            ],
            'tree': [
                [null, null, null, 1, null, null, null],
                [null, null, 1, 1, 1, null, null],
                [null, 1, 1, 1, 1, 1, null],
                [1, 1, 1, 0, 1, 1, 1],
                [null, null, null, 1, null, null, null],
                [null, null, null, 1, null, null, null],
                [null, null, 1, 1, 1, null, null]
            ]
        };

        // Simplified pattern matching - check each pattern directly
        console.log('Checking description:', description);
        
        if (description.includes('star')) {
            console.log('Matched: star');
            return patterns['star'];
        }
        if (description.includes('heart')) {
            console.log('Matched: heart');
            return patterns['heart'];
        }
        if (description.includes('arrow')) {
            console.log('Matched: arrow');
            return patterns['arrow'];
        }
        if (description.includes('hourglass') || description.includes('hour glass')) {
            console.log('Matched: hourglass');
            return patterns['hourglass'];
        }
        if (description.includes('butterfly') || description.includes('wings')) {
            console.log('Matched: butterfly');
            return patterns['butterfly'];
        }
        if (description.includes('diamond') || description.includes('gem')) {
            console.log('Matched: diamond');
            return patterns['diamond'];
        }
        if (description.includes('tree')) {
            console.log('Matched: tree');
            return patterns['tree'];
        }
        if (description.includes('smiley') || description.includes('smile') || description.includes('face')) {
            console.log('Matched: smiley');
            return patterns['smiley'];
        }
        if (description.includes('letter t') || description === 't' || description.includes('tee')) {
            console.log('Matched: letter t');
            return patterns['letter t'];
        }
        if (description.includes('letter l') || description === 'l') {
            console.log('Matched: letter l');
            return patterns['letter l'];
        }

        console.log('No pattern matched for:', description);
        return null;
    }

    displayShapeOnDesigner(pattern) {
        this.clearDesigner();
        
        // Add a small delay to ensure DOM is ready
        setTimeout(() => {
            for (let row = 0; row < 7; row++) {
                for (let col = 0; col < 7; col++) {
                    const cell = document.querySelector(`#board-designer [data-row="${row}"][data-col="${col}"]`);
                    if (!cell) {
                        console.error(`Cell not found at row ${row}, col ${col}`);
                        continue;
                    }
                    
                    const value = pattern[row][col];
                    
                    if (value === 1) {
                        cell.className = 'designer-cell marble';
                        cell.innerHTML = '<i class="bi bi-circle-fill"></i>';
                    } else if (value === 0) {
                        cell.className = 'designer-cell empty';
                        cell.innerHTML = '<i class="bi bi-circle"></i>';
                    } else {
                        cell.className = 'designer-cell invalid';
                        cell.innerHTML = '';
                    }
                }
            }
        }, 100);
    }

    renderBoard() {
        this.gameBoard.innerHTML = '';
        
        // Set the board class based on current shape
        this.gameBoard.className = `game-board ${this.currentShape}`;
        
        const boardSize = this.board.length;
        
        for (let row = 0; row < boardSize; row++) {
            for (let col = 0; col < boardSize; col++) {
                const cell = document.createElement('div');
                cell.className = 'hole';
                cell.dataset.row = row;
                cell.dataset.col = col;
                
                if (this.board[row][col] === null) {
                    cell.className = 'invalid-board-cell';
                } else {
                    if (this.board[row][col] === 1) {
                        const marble = document.createElement('div');
                        marble.className = 'marble';
                        marble.draggable = true;
                        marble.dataset.row = row;
                        marble.dataset.col = col;
                        cell.appendChild(marble);
                    }
                    
                    cell.addEventListener('click', (e) => this.handleCellClick(e, row, col));
                    cell.addEventListener('dragover', (e) => this.handleDragOver(e));
                    cell.addEventListener('drop', (e) => this.handleDrop(e, row, col));
                }
                
                this.gameBoard.appendChild(cell);
            }
        }
        
        // Add drag event listeners to marbles
        document.querySelectorAll('.marble').forEach(marble => {
            marble.addEventListener('dragstart', (e) => this.handleDragStart(e));
            marble.addEventListener('dragend', (e) => this.handleDragEnd(e));
        });
    }

    handleCellClick(e, row, col) {
        const marble = e.target.closest('.marble');
        
        if (marble && this.board[row][col] === 1) {
            this.selectMarble(row, col);
        } else if (this.selectedMarble) {
            this.attemptMove(this.selectedMarble.row, this.selectedMarble.col, row, col);
        }
    }

    selectMarble(row, col) {
        // Clear previous selection
        document.querySelectorAll('.marble').forEach(m => m.classList.remove('selected'));
        document.querySelectorAll('.hole').forEach(h => h.classList.remove('valid-drop'));
        
        this.selectedMarble = { row, col };
        const marble = document.querySelector(`[data-row="${row}"][data-col="${col}"].marble`);
        marble.classList.add('selected');
        
        // Highlight valid moves
        this.highlightValidMoves(row, col);
    }

    highlightValidMoves(row, col) {
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // up, down, left, right
        
        directions.forEach(([dRow, dCol]) => {
            const jumpRow = row + dRow * 2;
            const jumpCol = col + dCol * 2;
            const middleRow = row + dRow;
            const middleCol = col + dCol;
            
            if (this.isValidMove(row, col, jumpRow, jumpCol)) {
                const targetCell = document.querySelector(`[data-row="${jumpRow}"][data-col="${jumpCol}"].hole`);
                if (targetCell) {
                    targetCell.classList.add('valid-drop');
                }
            }
        });
    }

    isValidMove(fromRow, fromCol, toRow, toCol) {
        const boardSize = this.board.length;
        
        // Check bounds
        if (toRow < 0 || toRow >= boardSize || toCol < 0 || toCol >= boardSize) return false;
        
        // Check if target is valid board position and empty
        if (this.board[toRow][toCol] !== 0) return false;
        
        // Check if source has marble
        if (this.board[fromRow][fromCol] !== 1) return false;
        
        // Check if it's a jump of exactly 2 spaces
        const rowDiff = Math.abs(toRow - fromRow);
        const colDiff = Math.abs(toCol - fromCol);
        
        if (!((rowDiff === 2 && colDiff === 0) || (rowDiff === 0 && colDiff === 2))) return false;
        
        // Check if there's a marble to jump over
        const middleRow = fromRow + (toRow - fromRow) / 2;
        const middleCol = fromCol + (toCol - fromCol) / 2;
        
        return this.board[middleRow][middleCol] === 1;
    }

    attemptMove(fromRow, fromCol, toRow, toCol) {
        if (this.isValidMove(fromRow, fromCol, toRow, toCol)) {
            this.makeMove(fromRow, fromCol, toRow, toCol);
        } else {
            // Show invalid move feedback
            const targetCell = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
            if (targetCell && targetCell.classList.contains('hole')) {
                targetCell.classList.add('invalid');
                setTimeout(() => targetCell.classList.remove('invalid'), 500);
            }
        }
        
        this.clearSelection();
    }

    makeMove(fromRow, fromCol, toRow, toCol) {
        const middleRow = fromRow + (toRow - fromRow) / 2;
        const middleCol = fromCol + (toCol - fromCol) / 2;
        
        // Update board state
        this.board[fromRow][fromCol] = 0;
        this.board[middleRow][middleCol] = 0;
        this.board[toRow][toCol] = 1;
        
        this.moves++;
        this.renderBoard();
        this.updateStats();
        this.checkWinCondition();
    }

    clearSelection() {
        this.selectedMarble = null;
        document.querySelectorAll('.marble').forEach(m => m.classList.remove('selected'));
        document.querySelectorAll('.hole').forEach(h => h.classList.remove('valid-drop'));
    }

    updateStats() {
        const marbleCount = this.board.flat().filter(cell => cell === 1).length;
        this.marblesCount.textContent = marbleCount;
        this.movesCount.textContent = this.moves;
    }

    checkWinCondition() {
        const marbleCount = this.board.flat().filter(cell => cell === 1).length;
        
        if (marbleCount === 1) {
            // Check if the remaining marble is in the correct winning position for each shape
            const winPosition = this.getWinPosition();
            if (this.board[winPosition.row][winPosition.col] === 1) {
                this.showWinModal();
            }
        } else if (!this.hasValidMoves()) {
            // Game over - no more moves possible
            setTimeout(() => {
                alert(`Game Over! You have ${marbleCount} marbles remaining. Try again!`);
            }, 500);
        }
    }

    getWinPosition() {
        switch (this.currentShape) {
            case 'cross':
                return { row: 3, col: 3 }; // Center of 7x7 board
            case 'triangle':
                return { row: 0, col: 2 }; // Top of triangle
            case 'diamond':
                return { row: 2, col: 2 }; // Center of diamond
            case 'plus':
                return { row: 2, col: 2 }; // Center of plus
            case 'custom':
                // For custom boards, find the original empty position
                if (this.customBoard) {
                    for (let row = 0; row < this.customBoard.length; row++) {
                        for (let col = 0; col < this.customBoard[row].length; col++) {
                            if (this.customBoard[row][col] === 0) {
                                return { row, col };
                            }
                        }
                    }
                }
                return { row: 3, col: 3 }; // fallback
            default:
                return { row: 3, col: 3 };
        }
    }

    hasValidMoves() {
        const boardSize = this.board.length;
        
        for (let row = 0; row < boardSize; row++) {
            for (let col = 0; col < boardSize; col++) {
                if (this.board[row][col] === 1) {
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dRow, dCol] of directions) {
                        const jumpRow = row + dRow * 2;
                        const jumpCol = col + dCol * 2;
                        if (this.isValidMove(row, col, jumpRow, jumpCol)) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    showWinModal() {
        document.getElementById('final-moves').textContent = this.moves;
        this.winModal.classList.remove('hidden');
        
        // Add celebration animation to remaining marble
        const lastMarble = document.querySelector('.marble');
        if (lastMarble) {
            lastMarble.classList.add('celebrate');
        }
    }

    resetGame() {
        this.board = this.initializeBoard();
        this.moves = 0;
        this.selectedMarble = null;
        this.renderBoard();
        this.updateStats();
        this.winModal.classList.add('hidden');
    }

    showHint() {
        // Find a valid move and highlight it briefly
        const boardSize = this.board.length;
        
        for (let row = 0; row < boardSize; row++) {
            for (let col = 0; col < boardSize; col++) {
                if (this.board[row][col] === 1) {
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dRow, dCol] of directions) {
                        const jumpRow = row + dRow * 2;
                        const jumpCol = col + dCol * 2;
                        if (this.isValidMove(row, col, jumpRow, jumpCol)) {
                            this.selectMarble(row, col);
                            setTimeout(() => this.clearSelection(), 2000);
                            return;
                        }
                    }
                }
            }
        }
        alert('No valid moves found!');
    }

    changeShape(newShape) {
        if (newShape === 'custom') {
            this.customDesigner.classList.remove('hidden');
            return; // Don't switch immediately, wait for user to design board
        } else {
            this.customDesigner.classList.add('hidden');
        }
        
        this.currentShape = newShape;
        this.resetGame();
        
        // Update active shape button
        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[data-shape="${newShape}"]`).classList.add('active');
    }

    testCustomBoard() {
        const board = this.boardFromDesigner();
        const validation = this.validateCustomBoard(board);
        
        if (validation.valid) {
            this.customBoard = board;
            this.currentShape = 'custom';
            this.customDesigner.classList.add('hidden');
            this.resetGame();
            
            // Update active shape button
            document.querySelectorAll('.shape-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector('[data-shape="custom"]').classList.add('active');
            
            alert('Custom board loaded successfully!');
        } else {
            alert(validation.message);
        }
    }

    cancelCustomDesign() {
        this.customDesigner.classList.add('hidden');
        // Reset to previous shape button state
        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        document.querySelector(`[data-shape="${this.currentShape}"]`).classList.add('active');
    }

    setupEventListeners() {
        document.getElementById('reset-btn').addEventListener('click', () => this.resetGame());
        document.getElementById('hint-btn').addEventListener('click', () => this.showHint());
        document.getElementById('play-again-btn').addEventListener('click', () => this.resetGame());
        
        // Shape button listeners
        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const shape = btn.dataset.shape;
                this.changeShape(shape);
            });
        });

        // Custom designer event listeners
        document.getElementById('designer-marble').addEventListener('click', () => {
            this.setDesignerMode('marble');
        });
        
        document.getElementById('designer-empty').addEventListener('click', () => {
            this.setDesignerMode('empty');
        });
        
        document.getElementById('designer-invalid').addEventListener('click', () => {
            this.setDesignerMode('invalid');
        });
        
        document.getElementById('clear-designer').addEventListener('click', () => {
            this.clearDesigner();
        });

        document.getElementById('generate-from-description').addEventListener('click', () => {
            const description = document.getElementById('shape-description').value.trim();
            if (description) {
                if (!this.generateFromDescription(description)) {
                    alert(`Sorry, I don't recognize "${description}". Try: star, heart, arrow, letter T, letter L, etc.`);
                }
            } else {
                alert('Please enter a shape description first!');
            }
        });

        document.getElementById('test-custom-board').addEventListener('click', () => {
            this.testCustomBoard();
        });

        document.getElementById('save-custom-board').addEventListener('click', () => {
            const board = this.boardFromDesigner();
            const validation = this.validateCustomBoard(board);
            
            if (validation.valid) {
                const boardData = JSON.stringify(board);
                const blob = new Blob([boardData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'custom-marble-board.json';
                a.click();
                URL.revokeObjectURL(url);
                alert('Board saved to downloads!');
            } else {
                alert(validation.message);
            }
        });

        document.getElementById('cancel-custom').addEventListener('click', () => {
            this.cancelCustomDesign();
        });

        // Allow Enter key in description input
        document.getElementById('shape-description').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('generate-from-description').click();
            }
        });
        
        // Close modal when clicking outside
        this.winModal.addEventListener('click', (e) => {
            if (e.target === this.winModal) {
                this.winModal.classList.add('hidden');
            }
        });
    }

    // Drag and drop handlers
    handleDragStart(e) {
        const row = parseInt(e.target.dataset.row);
        const col = parseInt(e.target.dataset.col);
        this.selectedMarble = { row, col };
        e.target.classList.add('dragging');
        this.highlightValidMoves(row, col);
    }

    handleDragEnd(e) {
        e.target.classList.remove('dragging');
        this.clearSelection();
    }

    handleDragOver(e) {
        e.preventDefault();
    }

    handleDrop(e, row, col) {
        e.preventDefault();
        if (this.selectedMarble) {
            this.attemptMove(this.selectedMarble.row, this.selectedMarble.col, row, col);
        }
    }
}

// Initialize game when page loads
document.addEventListener('DOMContentLoaded', () => {
    // Fade in animation
    const elementsToAnimate = document.querySelectorAll('.fade-in-element');
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('is-visible');
                observer.unobserve(entry.target);
            }
        });
    }, { threshold: 0.1 });
    
    elementsToAnimate.forEach(el => observer.observe(el));
    
    // Initialize game
    new MarbleSolitaire();
});
</script>

</body>
</html> 
